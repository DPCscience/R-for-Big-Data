---
output: pdf_document
---
# Going to the next level with Rcpp

Sometimes R is just slow. You've tried every trick you know, and your code is still crawling along. At this point, you may need to turn to rewriting key parts of your code in C/C++. It is possible to write C and Fortran code without the need of any external packages, but it is incredibly painful and error prone. However there is a better way, the [Rcpp](http://www.rcpp.org) package. This is now one of the most popular packages on CRAN.  Rcpp provides a clean and friendly API that lets you write high-performance code, while at the same time, keeping you safe from R's tricky C API. The typical bottlenecks that C/C++ can address are loops and recursive functions.

C++ is a separate programming language and so it would not be possible to cover every aspect in this course. Instead, the goal is give a flavour of what's possible.

## Prerequistes

The code in this chapter was generated using Version `r packageDescription("Rcpp")$Version` of Rcpp. You can install Rcpp in the usual way

```{r eval=FALSE}
install.packages("Rcpp")
```
You also need a working C++ compiler. 
 * Linux: should already be installed. Otherwise install `r-base`
 * Macs: install `Xcode`
 * Windows, install [Rtools](http://cran.r-project.org/bin/windows/)
 
 To check that you have everything, try running the following piece of code from the course R package
 
 ```{r}
 ## TODO: write course package
 ```
 
## First steps
 
The beauty of Rcpp is that it is very easy to create C functions that R can use. We'll illustrate the key concepts by creating a simple `add` function. In R, the corresponding function would be a simple one line affair:
```{r} 
add_r = function(x, y) x + y
```
 
With Rcpp, we need a bit more. First we load the package
 
```{r message=FALSE}
library("Rcpp") 
```
 
Next we create function called `add_c`

```{r}
cppFunction('double add_c(double x, double y){
  double value = x+y;
  return value;
}')
```

When you run this code, Rcpp will magically compile the C++ code and construct a function that bridges the gap between R and C++.
```{r}
add_c
add_c(1, 2)
```
There are a few key differences between the R and C++ versions of `add`:

1. In the C++ function, each line is ended with `;`.
2. We must declare object types in the C++ version. In particular, we need to declare the types of the arguments, return value and any intermediate objects we create. This function returns a scaler of type `double`. Other common classes are: `NumericVector`, `IntegerVector`, `CharacterVector`, and `LogicalVector`.
3. The function must have an explicit `return` statement. Similar to R, there can be multiple returns, but the function will terminate when it hits it's first version.
4. You don't use assignment to create a function.

While the `cppFunction` is great for getting small examples up and running, it is much better practice to put your C++ in a separate file (with file extension `cpp`) and use the `sourceCpp("path/to/file.cpp")` function to compile them. However, we need to include a couple of headers. Once, at the top of the file, we need 

```{Rcpp eval=FALSE}
#include <Rcpp.h>
using namespace Rcpp;
```

then for each function, we we need to add

```{Rcpp eval=FALSE}
// [[Rcpp::export]]
```

This would give the total file

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double add_c(double x, double y){
  double value = x+y;
  return value;
}
```

There are two main benefits with putting your C++ functions in separate files. First, we have the benefit of syntax highlighting. Second, it's easier to make syntax errors when the switching between R and C++ in the same file. For the remainder of this chapter to save space, we we'll omit the headers.

## Vectors and loops


Let's consider a slightly more complicated example. Here we want to write our own function that calculates the mean. Note, this is just an example, R's version is much better and more robust to scale differences in our data. For comparison, let's create a corresponding R function. The function takes a single vector `x` as input, and returns the mean value, `m`:

```{r}
mean_r = function(x) {
  n = length(x)
  m = 0
  for(i in 1:n) 
    m = m + x[i]/n
  m
}
```

This is obviously a very bad R function, and we should just use the base function `mean`. However, the purpose of `mean_r` is to provide a comparison for the C++ version.

For the C++ version we need to specify the types of the argument `x` (`NumericVector`) and the return value (`double`). The object type `NumericVector`, isn't a standard C++ type, instead it is provided courtesy of Rcpp. The C++ version the `mean` function is a few lines longer. Almost always, the corresponding C++ version will be, possibly much, longer. 

```{Rcpp eval=FALSE}
double mean_c(NumericVector x){
  int i;
  int n = x.size();
  double mean = 0;
  
  for(i=0; i<n; i++){
    mean = mean + x[i]/n;
  }
  return mean;
}
``` 
To use the C++ function, we need to source the file (remember to put the necessary headers in)
```{r}
sourceCpp("src/mean_c.cpp")
```

Although the C++ version is similar, there are a few crucial differences.

1. We the `.size()` method to find the length of `x`
1. The `for` loop has a slightly different synext.
    ```{Rcpp eval=FALSE}
    for (variable initialization; condition; variable update ) {
       // Code to execute
    }
    ```
1. C++ provides operators to modify variables in place. So `i++` increases the value of `i` by `1`. Similarly, we could rewrite part of the loop as
    ```{Rcpp eval=FALSE}
    mean += x[i]/n;
    ```
   The above code adds `x[i]/n` to the value of `mean`. Other similar operators are `-=`, `*=`, `/=` and `i--`.
1. A C++ vector starts at `0` **not** `1`

We can use the `microbenchmark` package to compare the C++ and R versions

```{r}
library("microbenchmark")
```

This package is useful for comparing functions that run quickly. It serves as a more accurate replacement to `system.time(replicate(1000, expr))`. We will include the base R `mean` function in the comparison. We generate some normal random numbers for the comparison

```{r}
x = rnorm(1e4)
```

Then call the `microbenchmark` function.
```{r cache=TRUE}
z = microbenchmark(
  mean(x),
  mean_r(x),
  mean_c(x)
)
```
The results are easily compared using the `boxplot` method

```{r fig.width=5, fig.height=3, echo=2, fig.cap="Comparing C++ with R.", echo=2, cache=TRUE}
par(mar=c(3,3,2,1), mgp=c(2,0.4,0), tck=-.01, cex.axis=0.9, las=1)
boxplot(z)
grid()
```

## Matrices

Each vector type has a corresponding matrix equivilent: `NumericMatrix`, `IntegerMatrix`, `CharacterMatrix` and `LogicalMatrix`. We use this types in a similar way we used `NumericVector`'s. The main differences are:

 * When we initialise, we need specify the number of rows and columns
    ```{Rcpp, eval=FALSE}
    // 10 rows, 5 columns
    NumericMatrix mat(10, 5)
    ```
 * We subset using `()`, i.e. `mat(5, 4)`
 * The first view in a matrix is `mat(0, 0)` - remember indexes start with `0`
 * To determine the number of rows and columns, we use the `.nrow()` and `.ncol()` methods.


