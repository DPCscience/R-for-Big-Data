---
output: pdf_document
---

\chapter{Rcpp}

# Introduction

Sometimes R is just slow. You've tried every trick you know, and your code is still crawling along. At this point, you may need to rewrite key parts of your code in C/C++. It is possible to write C and Fortran code to interact with R without resorting to any external packages; but it is incredibly painful and error prone. However there is a better way, the Rcpp\sidenote{\url{http://www.rcpp.org}} package. This is now one of the most popular packages on CRAN.  Rcpp provides a clean and friendly API that lets you write high-performance code, while at the same time keeping you safe from R's tricky C API. The typical bottlenecks that C/C++ can address are loops and recursive functions.

In this chapter, C and C++ code are largely interchangeable, so when you see 'C code', it can usually be included in a `.cpp` file.`.cpp` is the default file extension for C++ scripts. In general, this isn't true. See for example the Stackoverflow question, \url{http://programmers.stackexchange.com/q/16390/14846} for an overview.

C++ is a separate programming language so every aspect cannot be covered in this course. Instead, the goal is to provide a flavour of what's possible.

\subsection*{Prerequistes}

The code in this chapter was generated using Version `r packageDescription("Rcpp")$Version` of Rcpp. You can install [Rcpp from CRAN](https://cran.r-project.org/web/packages/Rcpp/index.html) in the usual way

```{r eval=FALSE}
install.packages("Rcpp")
```

\noindent The associated CRAN\sidenote{\url{https://cran.r-project.org/web/packages/Rcpp/}} page has numerous vignettes that are worth looking at\sidenote{You can get an idea of the popularity of the package by looking at the `Reverse Imports`.}

To use the package, you also need a working C++ compiler. 

 * Linux: A compiler should already be installed. Otherwise install `r-base` it a compiler will be installed as a dependency.
 * Macs: Install `Xcode`.
 * Windows: Install [Rtools](http://cran.r-project.org/bin/windows/). Make sure you select the version that corresponds to your version of R.

\noindent To check that you have everything, try running the following piece of code from the course R package

```{r cache=TRUE}
library("r4bd")
test_rcpp()
```

# A simple C function

A C/C++ function is similar to an R function: you pass a set of inputs to function, some code is run, a single object is returned. However, there are some key differences

1. In the C/C++ function, each line must be terminated with `;`. In R, we use `;` only when have multiple statements on the same line.
2. We must declare object types in the C/C++ version. In particular, we need to declare the types of the functionarguments, return value and any intermediate objects we create. This function returns a scaler of type `double`. 
3. The function must have an explicit `return` statement. Similar to R, there can be multiple returns, but the function will terminate when it hits it's first `return` statement. However, in R we can omit `return`, with C
4. You don't use assignment to create a function.
5. Object assignment must use `=` sign. The `<-` operator isn't valid.

We want to create a function that adds two numbers together. In R, this would be a simple one line affair:

```{r} 
add_r = function(x, y) x + y
```

In C++, this is a bit more long winded

```{Rcpp eval=FALSE}
double add_c(double x, double y) {
    double value = x + y;
    return value;
  }
)
```

\textbf{Still in flux; not finished}
# First steps
 
The beauty of Rcpp is that it is very easy to create C++ functions that R can use. We'll illustrate the key concepts by creating a simple `add` function. In R, the corresponding function 
 
\noindent With Rcpp, we need a bit more. First we load the package
 
```{r message=FALSE}
library("Rcpp") 
```
 
\noindent Next we create function called `add_c`

```{r tidy=FALSE}
cppFunction('
  double add_c(double x, double y){
    double value = x + y;
    return value;
  }
')
```

\noindent When you run this code, Rcpp will magically compile the C++ code and construct a function that bridges the gap between R and C++.

```{r}
add_c
add_c(1, 2)
```

\noindent There are a few key differences between the R and C++ versions of `add`.



## C/C++ data types

The most basic type of variable is an integer, `int`. An `int` variable can store a value in the range $-32768$ to $+32767$\sidenote{In C, we can also define unsigned int'. Then the range goes from $0$ to $65,535$. There are also `long int` data types, which range from $0$ to $2^{31}-1$.}. To store floating point numbers, there are single precision numbers, `float` and double precision numbers, `double`. A `double` takes twice as much memory as a `float`.  For __single__ characters, we use the `char` data type.

\begin{table}[t]
  \centering
  \begin{tabular}{@{}ll@{}}
  \toprule
  Type & Description\\
  \midrule
  char & A single character.\\
  int & An integer.\\
  float & A single precision floating point number.\\
  double & A double-precision floating point number.\\
  void & A valueless quantity.\\
  \bottomrule
  \end{tabular}
  \caption{Overview of key C/C++ object types.}
\end{table}

A pointer object, is a variable that points to an area of memory that has been given a name.Pointers are a very powerful, but primitive facility contained in the C language. They are very useful since rather than passing large object around, we pass a pointer to the memory location. We won't use pointers in this chapter, but mention them for completeness.

# The cppFunction function





\noindent The `cppFunction` is great for getting small examples up and running. But it is better practice to put your C++ in a separate file (with file extension `cpp`) and use the `sourceCpp("path/to/file.cpp")` function to compile them. However, we need to include a couple of headers. At the top of the file, we need 

```{Rcpp eval=FALSE}
#include <Rcpp.h>
using namespace Rcpp;
```

\noindent then for each function we want to export (use in R), we need to add

```{Rcpp eval=FALSE}
// [[Rcpp::export]]
```

\noindent This would give the total file

```{Rcpp}
#include <Rcpp.h>
using namespace Rcpp;

// [[Rcpp::export]]
double add_c(double x, double y){
  double value = x + y;
  return value;
}
```

\noindent There are two main benefits with putting your C++ functions in separate files. First, we have the benefit of syntax highlighting (RStudio has great support for C++ editing). Second, it's easier to make syntax errors when the switching between R and C++ in the same file. To save space, we we'll omit the headers for the remainder of the chapter.

# Vectors and loops

Let's consider a slightly more complicated example. Here we want to write our own function that calculates the mean. Note, this is just an illustrative example: R's version is much better and more robust to scale differences in our data. For comparison, let's create a corresponding R function. The function takes a single vector `x` as input, and returns the mean value, `m`:

```{r}
mean_r = function(x) {
  n = length(x)
  m = 0
  for(i in 1:n) 
    m = m + x[i]/n
  m
}
```

\noindent This is a very bad R function. We should just use the base function `mean` for real world applications. However, the purpose of `mean_r` is to provide a comparison for the C++ version, which we will write in a similar way.

For the C++ version we need to specify the types of the argument `x` (`NumericVector`) and the return value (`double`). The object type `NumericVector`, isn't a standard C++ type, instead it is provided courtesy of Rcpp. Other common classes are: `NumericVector`, `IntegerVector`, `CharacterVector`, and `LogicalVector`. The C++ version of the `mean` function is a few lines longer. Almost always, the corresponding C++ version will be, possibly much, longer. 

```{Rcpp eval=FALSE}
double mean_c(NumericVector x){
  int i;
  int n = x.size();
  double mean = 0;
  
  for(i=0; i<n; i++){
    mean = mean + x[i]/n;
  }
  return mean;
}
``` 

\noindent To use the C++ function, we need to source the file (remember to put the necessary headers in).

```{r}
sourceCpp("src/mean_c.cpp")
```

\noindent Although the C++ version is similar, there are a few crucial differences.

1. We use the `.size()` method to find the length of `x`
1. The `for` loop has a slightly more complicated syntax.
    ```{Rcpp eval=FALSE}
    for (variable initialization; condition; variable update ) {
       // Code to execute
    }
    ```
1. C++ provides operators to modify variables in place. So `i++` increases the value of `i` by `1`. Similarly, we could rewrite part of the loop as
    ```{Rcpp eval=FALSE}
    mean += x[i]/n;
    ```
   The above code adds `x[i]/n` to the value of `mean`. Other similar operators are `-=`, `*=`, `/=` and `i--`.
1. A C++ vector starts at `0` **not** `1`

We can use the `microbenchmark` package to compare the C++ and R versions

```{r}
library("microbenchmark")
```

\noindent This package is useful for comparing functions that run quickly. It serves as a more accurate replacement to `system.time(replicate(1000, expr))`. We will include the base R `mean` function in the comparison. We generate some normal random numbers for the comparison

```{r}
x = rnorm(1e4)
```

\noindent Then call the `microbenchmark` function.

```{r cache=TRUE}
z = microbenchmark(
  mean(x),
  mean_r(x),
  mean_c(x)
)
```

\noindent The results are easily compared using the `boxplot` method

```{r fig.width=5, fig.height=3, echo=2, fig.cap="Comparing C++ with R.", echo=2, cache=TRUE}
par(mar=c(3,3,2,1), mgp=c(2,0.4,0), tck=-.01, cex.axis=0.9, las=1)
boxplot(z)
grid()
```

\noindent In this simple example, the C++ variant is around $100$ times faster than the corresponding R version.

## Matrices

Each vector type has a corresponding matrix equivalent: `NumericMatrix`, `IntegerMatrix`, `CharacterMatrix` and `LogicalMatrix`. We use these types in a similar way to how we used `NumericVector`'s. The main differences are:

 * When we initialise, we need specify the number of rows and columns
    ```{Rcpp, eval=FALSE}
    // 10 rows, 5 columns
    NumericMatrix mat(10, 5);
    // Length 10
    NumericVector v(10);
    ```

 * We subset using `()`, i.e. `mat(5, 4)`.
 * The first view in a matrix is `mat(0, 0)` - remember indexes start with `0`.
 * To determine the number of rows and columns, we use the `.nrow()` and `.ncol()` methods.

## Comments

In C++, we can comment our code in two ways. If we want a one line comment, we use the `//` notation:

```{Rcpp}
// A one line comment
```

\noindent If we want a multi-line comment, then we use

```{Rcpp}
/*
 A multi-line
 comment
*/ 
```

\noindent In the previous section we decorated the C++ functions with `// [[Rcpp::export]]` (note the space between `//` and `[[`). This uses the same idea as the `roxygen2` package and the `@export` control. The comment indicates that the function should be exported to C++. 

One further trick that Rcpp provides is that we can embed R code in the Cpp file
```{Rcpp}
/*** R
1 + 1
*/
```

\noindent This can be particularly helpful when testing code.

# C++ with sugar on top

Rcpp sugar brings a higher-level of abstraction to C++ code written using the Rcpp API. What this means in practice is that we can write C++ code in the style of R. 

Let's suppose we want to create a C++ function that finds the squared difference between two R vectors; the squared residual in a regression analysis. Making sure we have the correct headers, we would try something like

```{Rcpp eval=FALSE}
NumericVector res_c(NumericVector x, NumericVector y){
  int i;
  int n = x.size();
  NumericVector residuals(n);
  for(i=0; i<n; i++){
    residuals[i] = pow(x[i] - y[i], 2);
  }
  return residuals;
}
```

\noindent With `Rcpp` sugar, we can rewrite this code to be more succinct and have more of an R feel, 

```{Rcpp eval=FALSE}
NumericVector res_sugar(NumericVector x, NumericVector y){
  return pow(x-y, 2);
}
```

\noindent The sugar versions aren't usually faster than the C++ version, but there's usually very little difference between the two. However, with the sugared variety, the code is shorter and is constantly being improved.

> Challenge (hard): In the above example, `res_sugar` is faster than `res_c`. Do you know why?


